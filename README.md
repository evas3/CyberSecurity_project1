# Cyber Security course project I
This is a project for HY course ['Cyber Security Base 2025 course project I'](https://cybersecuritybase.mooc.fi/module-3.1). It features a web application that has at least 5 different flaws from the OWASP top ten list. The project also features their fixes.


Website is build using Python and Django. Axios is also necessary for the fixed version.

## Security flaws
This project includes security flaws listed on OWASP top 10 2021 list + CSRF

### Flaw 1: CSRF (cross site request forgery, not included in OWASP top 10 list)
[Flaw 1 pinpointed](https://github.com/evas3/CyberSecurity_project1/blob/main/src/pages/templates/pages/login.html#L11)
[Flaw 1 pinpointed](https://github.com/evas3/CyberSecurity_project1/blob/main/src/pages/templates/pages/signup.html#L10)
**Description:** Cross site request forgery is an attack in which an authenticated user’s browser is tricked into making unwanted HTTP requests. If the user is logged in to this application an attacker can create a malicious link where once that link is clicked the user's browser sends a request to this application without the user's knowledge. 
**Fix:** (Because the application uses Django and doesn’t run without this fix, the flaw is already fixed.) In order to prevent cross site request forgery attacks each form needs to include a csrf-token ({% csrf_token %} ). For this application the token is added for login and signup form and sent with username and password input when the form is submitted. Csrf-token is unique and unpredictable. If the token is missing from the POST request made when the form is submitted or the token is incorrect the request is rejected. 

### Flaw 2: Cryptographic failures
[Flaw 2 pinpointed](https://github.com/evas3/CyberSecurity_project1/blob/main/src/pages/views.py#L57-L60)
**Description:** Cryptographic failures refer to vulnerabilities caused by for example weak or badly enforced encryption algorithms or protocols. Sensitive data such as passwords need protection during transit and when at rest so that attackers can’t gain access to it. This application stores the password made by the user during signup with User.objects.create(). This means that the password is stored in a non secure way as cleartext. This can be confirmed using shell command print(User.objects.first().password).
**Fix:** For the fix I use User.objects.create_user() instead of User.objects.create(). This way the password is hashed before it is stored. When the password is not stored as cleartext, “if User.objects.filter(username=username, password=password).exists()” can’t be used to check whether or not the password is correct so instead I use authenticate().

### Flaw 3: Security misconfiguration
[Flaw 3 pinpointed](https://github.com/evas3/CyberSecurity_project1/blob/main/src/config/settings.py#L26-L27)
**Description:** Security misconfigurations refer to vulnerabilities caused by the applications security settings being improperly configured. Various security misconfigurations may make the application insecure and vulnerable to attacks. The OWASP top 10 list description of this security risk includes unnecessary features being enabled, improper permission configuration on cloud servers and error handling that reveals informative messages to users. Here the application is configured for better debugging with DEBUG = True which is the default when starting a new Django project. This configuration is not fitting for an application that is already in production since the error messages reveal too much information to the end user and attackers can use this information to their advantage. Other configurations in use for this application are also not fit for an application that is already in production. Secret key for example is visible for all. An automated deployment checklist can be seen with command “python3 manage.py check --deploy”.
**Fix:** For an application that is in production the debug mode has to be turned off with configuration DEBUG = False. When the debugging mode is turned off the error messages won’t include informative messages. ALLOWED_HOSTS needs to also be reconfigured to to serve requests from all allowed hosts on the list. In this fix it’s simply configured to serve requests from 127.0.0.1.

### Flaw 4: Identification and authentication failures
[Flaw 4 pinpointed](https://github.com/evas3/CyberSecurity_project1/blob/main/src/pages/views.py#L54-L60)
[Flaw 4 pinpointed](https://github.com/evas3/CyberSecurity_project1/blob/main/src/pages/views.py#L25-L26)
**Description:** Identification and authentication failures include weaknesses in how the application confirms the user’s identity and how the session is managed. Some problems OWASP top 10 list points out for this category include the session identifier being visible in the URL and use of weak credential recovery. Attackers can exploit these weaknesses in order to gain access to another user's account. Other authentication weaknesses include the application permitting automated attacks and use of weak passwords. Said weaknesses are a problem for this application asswell. Users can try to log in as many times as they want without restrictions. Attackers can try to gain user credentials using a brute force attack. Application also allows users to use weak passwords when signing up which are easy to brute force.
**Fix:** For the fix signup form uses Django-Axes to check if the password is strong enough. In this case the username and password can’t be the same string, the password can’t be entirely numeric and it can’t be featured on Axios common password list. The length of the passwords is also checked and needs to be at least 8 characters. Brute force attacks can be prevented by tracking failed login attempts and restricting the amount of possible failed attempts in a certain timeframe. Axes is used for that as well and it restricts the amount of failed login attempts to 5. After 5 failed attempts users can’t try to login in an hour with the same username or ip-address. Note that for the fix it is necessary to also edit the settings file in src/config.

### Flaw 5: Security logging and monitoring failures
[Flaw 5 pinpointed](https://github.com/evas3/CyberSecurity_project1/blob/main/src/pages/views.py#L25-L26)
**Description:** If events such as failed logins and other relevant actions aren’t monitored and logged, brute force attacks may go unnoticed and actions can’t be done to further prevent such attacks. This application here doesn’t monitor or log failed login attempts so an attacker can try another user's password as many times as it takes to guess it without being noticed or any actions being taken on the applications part to stop this.
**Fix:** There are ready made security loggers to fix this issue. In this case the application should log failed login attempts to protect users accounts. Brute force attacks can be prevented by tracking failed login attempts and restricting the amount of possible failed attempts in a certain timeframe. Here I use Django-Axes for that. For each failed login attempt axios logs user-agent information, users ip-address and the username used. Users have to wait an hour after 5 failed login attempts. Note that for the fix it is necessary to also edit the settings file in src/config.


### Flaw 6: Broken access control
[Flaw 6 pinpointed](https://github.com/evas3/CyberSecurity_project1/blob/main/src/pages/views.py#L80-L81)
**Description:** Broken access control category on OWASP top 10 list refers to poorly implemented access control where users can act outside their intended permissions. Some examples of this on OWASP list include violation of the least privilege principle and the application permitting viewing someone else's account. This application's login doesn’t actually work as intended and the user site can be accessed by anyone regardless if they have logged in or not. Because of this elevation of privileges someone can act as a user without being logged in.
**Fix:** For the fix login is implemented using django login function and the user page is restricted to only users who have logged in. If a user who hasn’t logged in tries to access the user's page, they will be redirected to the login page.
